[
  {
    "objectID": "wavelet.html",
    "href": "wavelet.html",
    "title": "Wavelet analysis",
    "section": "",
    "text": "Check synchrony in the number of measles cases between SEA countries\nMethod: wavelet analysis to assess\n\nSeasonal pattern (1 year cycle, depends on school year, etc.)\nMultiannual patterns (multiple years, typically years between major epidemics)"
  },
  {
    "objectID": "wavelet.html#data-processing",
    "href": "wavelet.html#data-processing",
    "title": "Wavelet analysis",
    "section": "Data processing",
    "text": "Data processing\n\nLoad data\n\n\nLoad measles epicurve data for SEA countries\nsuppressMessages(library(tidyverse))\nlibrary(janitor)\nlibrary(plotly)\nlibrary(patchwork)\n\nworld_epi_curve <- readxl::read_excel(\n  \"data/404-table-web-epi-curve-data.xlsx\",\n  sheet = \"WEB\")\n\n# --- preprocess ----- \nworld_epi_curve <- world_epi_curve %>% \n  clean_names() %>% \n  mutate(\n    date = ym(str_c(year, month)),\n    measles_clinical = as.integer(measles_clinical)\n  ) \n\nfiltered_countries <- c(\n  \"Viet Nam\", \"Thailand\", \"Cambodia\", \"Malaysia\", \"Singapore\", \"Myanmar\", \"Philippines\",\"Brunei Darussalam\", \"Timor-Leste\", \"Indonesia\",\n  \"Lao People's Democratic Republic\")\n\n# get epi curve of South East Asia countries\nsea_epi_curve <- world_epi_curve %>% \n  clean_names() %>% \n  mutate(\n    date = ym(str_c(year, month)),\n    measles_suspect = as.integer(measles_suspect),\n    measles_clinical = as.integer(measles_clinical),\n    measles_epi_linked = as.integer(measles_epi_linked),\n    measles_lab_confirmed = as.integer(measles_lab_confirmed),\n    # NOTE: recompute measles total since some epi-linked cases are negative (e.g. record for Indonesia on 2016-10-01)\n    # definition: t sum of clinically-compatible, epidemiologically linked and laboratory-confirmed cases\n    measles_total = abs(measles_clinical) + abs(measles_epi_linked) + abs(measles_lab_confirmed)\n  ) %>% \n  filter(\n    country %in% filtered_countries\n  ) \n\n\n\n\nClean data\n\nThe column used for incidence data is measles total (sum of clinical compatible cases, epi-linked cases, laboratory confirmed cases)\nMake sure the the time series is even-spaced\nCheck % of missing data from each of the 11 SEA countries\n\n\n\nGenerate evenly spaced time series for all countries\ndate_range <- range(sea_epi_curve$date)\nsea_epi_curve <- sea_epi_curve %>% \n  group_by(country) %>%\n  rename(\n    incidence = measles_total\n  ) %>% \n  complete(\n    date = seq(date_range[1], date_range[2], by = \"month\"),\n    fill = list(\n      incidence = 0\n    )\n  ) %>% \n  ungroup()\n\n\nView the percentage of data points where incidence==0\n\n\nGet country with most incidence report being 0\npercent_zero <- sea_epi_curve %>% \n  group_by(country) %>% \n  summarize(\n    percent_zero = sum(incidence == 0)/n()\n  ) %>% \n  arrange(\n    desc(percent_zero)\n  ) \n\n# filtered out countries where percent of data points where incidence = 0 > 50%\nhigh_pct_zero <- percent_zero %>% filter(percent_zero > 0.5) %>% pull(country)\n\n\n\n\nPlot incidence\n\n\nPlor raw incidence\nsea_epicurve_plot <- sea_epi_curve %>% \n  filter(!(country %in% high_pct_zero)) %>% \n  ggplot() +\n  geom_line(\n    aes(\n      x = date,\n      y = incidence,\n      color = country\n    )\n  ) \n\nggplotly(sea_epicurve_plot)\n\n\n\n\n\n\n\n\nPreprocess data\nFollow these steps\n\nLog transform\nNormalized\nRemove latest observation of each country (most likely under-reported)\n\n\n\nPreprocess data\nfiltered_sea_epicurve <- sea_epi_curve %>% \n  filter(!(country %in% high_pct_zero)) \n\nlog_transformed <- filtered_sea_epicurve %>% \n  group_by(country) %>% \n  mutate(\n    # log transform\n    incidence = log10(incidence + 1),\n    # normalized\n    incidence = (incidence - mean(incidence))/sd(incidence)\n  ) %>% \n  filter(\n    date != max(date)\n  ) %>% \n  ungroup()\n\n\n\n\nPlot preprocessed data\nlog_epicurve_plot <- log_transformed %>% \n  ggplot() +\n  geom_line(\n    aes(\n      x = date,\n      y = incidence,\n      color = country\n    )\n  ) \n\nggplotly(log_epicurve_plot)"
  },
  {
    "objectID": "wavelet.html#wavelet-analysis",
    "href": "wavelet.html#wavelet-analysis",
    "title": "Wavelet analysis",
    "section": "Wavelet analysis",
    "text": "Wavelet analysis\n\nlibrary(WaveletComp)\n\nFollow these steps of wavelet analysis\n\nInspect the power spectrum across time-period domain: identify the period that is consistently high over time, which indicates recurring cycles in the time series.\nInspect the global power (time-averaged power, analogue of the Fourier transform): identify the overall dominant periodicities.\nInspect the period-specific reconstructed component: extract period-specific oscillations to assess their contributions to the time series.\nInspect the period-specific phase: visualize the timing of cycles of different time series.\n\nGeneral setup\n\n1 time unit is 1 year. Since the data is collected every month, dt = 1/12\nThe analyzed range of period is [1/6, 8] (i.e., 2 months to 8 years)\n\n\nAnalyze on Vietnam data only\n1. Check power spectrum across time-period\n\nConsistently high power at period=5 suggests a cycle of major epidemic every 5-years, which can be observed from indicence data.\nThe plot also suggests (roughly) biennial cycle.\nAnnual cycle (seasonality) is only weakly detected before 2017 (maybe due to under-reporting).\n\n\n\nCode\ncapture.output(\n  wavelet <- log_transformed %>% \n    filter(\n      country == \"Viet Nam\"\n    ) %>% \n    analyze.wavelet(\n      my.series = \"incidence\",\n      dt = 1/12,\n      lowerPeriod = 1/6,\n      upperPeriod = 8,\n      verbose = FALSE\n    )\n) %>% invisible()\n\nwt.image(wavelet, \n         # n.levels = 250, \n         legend.params = list(lab = \"Power\"),\n         periodlab = \"Period(Year)\",\n         show.date=TRUE)\n\n\n\n\n\n2. View global power (i.e., mean power across time)\n\nwt.avg(wavelet)\n\n\n\n\n3. Check the period specific reconstructed component\n\n5-year2-year1-year\n\n\nreconstructed component for 5-year period\n\n\nCode\nreconstruct(\n  wavelet,\n  sel.period = 5,\n  plot.rec = TRUE,\n  show.date = TRUE,\n  verbose = FALSE\n)\n\n\n\n\n\n\n\nReconstructed component for 2-year period (biennial)\n\n\nCode\nreconstruct(\n  wavelet,\n  sel.period = 2,\n  plot.rec = TRUE,\n  show.date = TRUE,\n  verbose = FALSE\n)\n\n\n\n\n\n\n\nReconstructed component for 1-year period (seasonal)\n\n\nCode\nreconstruct(\n  wavelet,\n  sel.period = 1,\n  plot.rec = TRUE,\n  show.date = TRUE,\n  verbose = FALSE\n)\n\n\n\n\n\n\n\n\n4. Visualize phase angle (in radians)\n\n5-year2-year\n\n\n\n\nPlot phase\n# get the column for the 5-year period\nrow_5year <- which.min(abs(wavelet$Period - 5))\n\ndata.frame(\n  date = wavelet$series$date,\n  phase = wavelet$Phase[row_5year,]\n) %>% \n  ggplot() +\n  geom_line(\n    aes(\n      x = date,\n      y = phase\n    ), color = \"cornflowerblue\"\n  )\n\n\n\n\n\n\n\n\n\nPlot phase\n# get the column for the 2-year period\nrow_2year <- which.min(abs(wavelet$Period - 2))\n\ndata.frame(\n  date = wavelet$series$date,\n  phase = wavelet$Phase[row_2year,]\n) %>% \n  ggplot() +\n  geom_line(\n    aes(\n      x = date,\n      y = phase\n    ), color = \"cornflowerblue\"\n  )\n\n\n\n\n\n\n\n\n\n\nPerform analysis on all data\nExclusion criteria:\n\nPercentage of records where incidence = 0 greater than 50% (Brunei, Timer-Leste, Laos, Cambodia)\nLow case count across time series (Singapore)\n\n\n\nPerform wavelet data analysis on SEA countries\nanalyze_countries <- c(\"Thailand\", \"Myanmar\", \"Philippines\", \"Viet Nam\", \n                       \"Malaysia\", \"Indonesia\")\n\ncountries_wavelets <- log_transformed %>% \n  filter(country %in% analyze_countries) %>%\n  group_by(country) %>% \n  nest() %>% \n  mutate(\n    wavelet = map(data, \\(dat){\n      capture.output(\n        out <- dat %>% \n        analyze.wavelet(\n          my.series = \"incidence\",\n          dt = 1/12, # 1 time unit = 1 year \n          lowerPeriod = 1/6, # 2 months\n          upperPeriod = 8, #  years\n          verbose = FALSE\n        )\n      ) %>% invisible()\n        \n      out\n    })\n  ) %>% \n  select(country, wavelet) %>%\n  deframe()\n\n\n\n\nPower spectrum\nThese plots suggest that most analyzed SEA countries experience measles epidemic every 4-5 years\n\n\nFunction to plot power spectrum of all countries\nplot_power <- function(wavelets){\n  # return heatmap of power and also global power\n  imap(wavelets, \\(wavelet, country){\n    wt.image(\n        wavelet,\n        main = paste0(country, \" power spectrum\"),\n        legend.params = list(lab = \"Power\"),\n        periodlab = \"Period(Year)\",\n        show.date = TRUE\n      )\n    \n    wt.avg(\n        wavelet,\n        main = paste0(country, \" global power\")\n      )\n  })\n}\n\n\n\nplot_power(countries_wavelets)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n$Indonesia\nNULL\n\n$Malaysia\nNULL\n\n$Myanmar\nNULL\n\n$Philippines\nNULL\n\n$Thailand\nNULL\n\n$`Viet Nam`\nNULL\n\n\n\n\nReconstructed component\n\n\nFunction to plot period specific component\nreconstruct_ts <- function(wavelets, period = 5){\n  df <- map2_dfr(wavelets, names(wavelets), \\(wavelet, country){\n    rec_period <- reconstruct(\n      wavelet,\n      sel.period = period,\n      plot.rec = FALSE,\n      verbose = FALSE\n    )\n    \n    rec_period$series %>%\n      mutate(country = country, .before = 1)\n  })\n  \n  plot <- df %>% \n    ggplot() +\n      geom_line(\n        aes(x = date, y = incidence.r, color = country)\n      ) +\n      labs(\n        y = paste0(round(mean(period), digits = 2), \"-year period component\"),\n        x = \"Date\"\n      )\n  \n  # return data.frame and plot\n  list(\n    df = df,\n    plot = plot\n  )\n}\n\n\n\n5-year2-year1-year\n\n\nTake the average of the components of period ranging from 4-5.\nClear oscillations can be observed across all the countries, which further confirm the observations from previous section.\n\nggplotly(\n  reconstruct_ts(countries_wavelets, period = c(4,5))$plot\n)\n\n\n\n\n\n\n\nRoughly biennial component. Take the average of the components of period ranging from 1.9-2.5.\nRelatively consistent oscillation can be observed for Vietnam and Thailand which suggests biennial cycle exists for these 2 countries.\n\nggplotly(\n  reconstruct_ts(countries_wavelets, period = c(1.9, 2.5))$plot\n)\n\n\n\n\n\n\n\nThe plot suggests no SEA country exhibits consistent annual measles cycles\n\nggplotly(\n  reconstruct_ts(countries_wavelets, period = 1)$plot\n)\n\n\n\n\n\n\n\n\n\n\nPhase\n\n\nFunction to plot period-specific phase\ncompute_phase <- function(wavelets, period = 5){\n  df <- map2_dfr(wavelets, names(wavelets), \\(wavelet, country){\n    \n    # if only one period is given -> select the closest period\n    # else select all period within the range\n    row_period <- if(length(period) == 1) which.min(abs(wavelet$Period - period)) else\n      which( (wavelet$Period >= min(period)) & (wavelet$Period <= max(period)) )\n    \n    data.frame(\n      date = wavelet$series$date,\n      # compute mean phase across all selected periods\n      phase = if(length(row_period) > 1) colMeans(wavelet$Phase[row_period,]) else wavelet$Phase[row_period,]\n    ) %>% \n      mutate(\n        country = country,\n        .before = 1\n      )\n  })\n  \n  plot <- df %>% \n    ggplot() +\n      geom_line(\n        aes(x = date, y = phase, color = country)\n      ) +\n      labs(\n        y = \"Phase\",\n        x = \"Date\"\n      )\n  \n  # return data.frame and plot\n  list(\n    df = df,\n    plot = plot\n  )\n}\n\n\n\n5-year2.5-year\n\n\nMajor epidemics cycle (roughly 5 years)\n\ncountries_phase <- compute_phase(countries_wavelets, period = 5)\n\nggplotly(countries_phase$plot)\n\n\n\n\n\n\n\nRoughly biennial epidemic\n\ncountries_phase <- compute_phase(countries_wavelets, period = 2.5)\nggplotly(countries_phase$plot)"
  },
  {
    "objectID": "wavelet.html#cross-wavelet-analysis",
    "href": "wavelet.html#cross-wavelet-analysis",
    "title": "Wavelet analysis",
    "section": "Cross-wavelet analysis",
    "text": "Cross-wavelet analysis\nFollow these steps of cross-wavelet analysis:\n\nInspect the cross-wavelet power spectrum: identify the period that consistently recurring for both pair of time series.\nInspect the coherence spectrum: identify the period where the pair of time series consistently correlates.\nInspect the period-specific phase difference: check the relative timing of the 2 time series (which series lead the other).\nCompute and inspect the period-specific synchrony: check how closely the 2 time series align.\n\n\n\nFunction to generate biwavelet analyses for multiple pairs\nlibrary(janitor)\n\n# Function that takes data instead of wavelets\n# wavelets, period = 5, ref_country = \"Viet Nam\", constraint = TRUE, diff_to_time = TRUE\n# when ref_country is not found, generate all unique pairs \ngenerate_biwavelet_analysis <- function(data, \n                                        ref_country = \"Viet Nam\",\n                                        verbose = FALSE){\n  countries <- unique(data$country)\n  \n  # generate all unique pairs\n  pairs <- combn(countries, 2, simplify = FALSE)\n  \n  # if ref country is provided, keep pairs with the ref_country\n  # also make sure ref country is the first time series\n  if (!is.na(ref_country)){\n    pairs <- keep(pairs, \\(p) ref_country %in% p)\n    pairs <- map(pairs, \\(p) {\n      if (p[1] == ref_country) p else rev(p)\n    })\n  }\n  \n  coherence <- map(pairs, \\(curr_pair){\n    capture.output(\n      out <- data %>% \n      filter(\n        country %in% curr_pair\n      ) %>% \n      select(country, date, incidence) %>% \n      pivot_wider(\n        names_from = country,\n        values_from = incidence\n      ) %>%\n      as.data.frame() %>% \n      analyze.coherency(\n        my.pair = curr_pair,\n        dt = 1/12,\n        lowerPeriod = 1/6,\n        upperPeriod = 8,\n        verbose = verbose\n      )\n    ) %>% invisible()\n    \n    out\n  })\n  \n  names(coherence) <- map_chr(pairs, \\(pair) paste(pair, collapse = \" - \"))\n\n  coherence\n}\n\n\n\n\nFunction to generate cross-wavelet power spectrum plot\nplot_cwavelet_power <- function(coherence_list){\n  # return heatmap of power and also global power\n  imap(coherence_list, \\(coherence, label){\n    wc.image(\n        coherence,\n        # set significance level for drawing contour (white line around an area)\n        siglvl.contour = 0.1, \n        # set significance level for drawing arrows\n        siglvl.arrow = 0.05, which.arrow.sig = \"wt\",\n        main = paste0(label, \" power spectrum\"),\n        legend.params = list(lab = \"cross-wavelet power\"),\n        periodlab = \"Period(Year)\",\n        show.date = TRUE\n      )\n    \n    wc.avg(\n        coherence,\n        main = paste0(label, \" global power\")\n      )\n  })\n}\n\n\n\ncapture.output(\n  countries_coherence <- log_transformed %>% \n    filter(country %in% analyze_countries) %>% \n    generate_biwavelet_analysis()\n) %>% invisible()\n\n\nCross-wavelet power spectrum\nInterpretation of the arrows:\n\nhorizontal arrows pointing to the right indicate in-phase\nhorizontal arrows pointing to the left indicate anti-phase\n\nSome notable observations at the 4-5 period (major epidemics cycle):\n\nthe measles cycle of Vietnam - Philippines started out in-phase but slowly turns out of phase at the end\nthe measles cycle of Vietnam - Thailand started out out of phase phase but slowly out turns in-phase (around the 2021 year mark)\n\n\nplot_cwavelet_power(countries_coherence)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n$`Viet Nam - Indonesia`\nNULL\n\n$`Viet Nam - Malaysia`\nNULL\n\n$`Viet Nam - Myanmar`\nNULL\n\n$`Viet Nam - Philippines`\nNULL\n\n$`Viet Nam - Thailand`\nNULL\n\n\n\n\nCoherence\nPlot coherence over time-period\n\n\nFunction to plot coherence\nplot_coherence <- function(coherence_list){\n  out <- map2(names(coherence_list), coherence_list, \\(label, analysis){\n      wc.image(\n        analysis,\n        which.image = \"wc\",\n        # set significance level for drawing contour (white line around an area)\n        siglvl.contour = 0.1, \n        # set significance level for drawing arrows\n        siglvl.arrow = 0.05, which.arrow.sig = \"wt\",\n        main = paste0(label, \" coherence plot\"),\n        legend.params = list(lab = \"wavelet coherence level\"),\n        periodlab = \"Period(Year)\",\n        show.date = TRUE\n      )\n  })\n  \n  names(out) <- names(coherence_list)\n  out\n}\n\n\n\nwc_plots <- plot_coherence(countries_coherence)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot average coherence at each period across time\n\n\nFunction to plot average coherence\nplot_avg_coherence <- function(coherence_list){\n  map2(names(coherence_list), coherence_list, \\(label, analysis){\n    # compute data for plotting\n    df <- data.frame(\n      period = analysis$Period,\n      avg_coherence = analysis$Coherence.avg,\n      p_val = analysis$Coherence.avg.pval\n    ) %>% \n      mutate(\n        p_val_label = case_when(\n          p_val <= 0.05 ~ \"<= 0.05\",\n            p_val <= 0.1 ~ \"<= 0.1\",\n            .default = \">0.1\"\n        )\n      )\n    \n    ggplot() +\n      geom_line(\n        aes(\n          x = period, y = avg_coherence\n        ),\n        data = df\n      ) +\n      geom_point(\n        aes(\n          x = period, y = avg_coherence, color = p_val_label\n        ), \n        data = df %>% filter(p_val_label != \">0.1\")\n      ) + \n      labs(\n        title = paste0(\"Average coherence of \", label),\n        x = \"Period\",\n        y = \"Coherence\",\n        color = \"p-value\"\n      )\n  })\n}\n\n\n\nplot_avg_coherence(countries_coherence)\n\n[[1]]\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n[[3]]\n\n\n\n\n\n\n[[4]]\n\n\n\n\n\n\n[[5]]\n\n\n\n\n\n\n\nPhase difference\n\n\nFunction to compute phase difference\n# alternative way to get phase difference\ncompute_phase_diff <- function(coherence_list, period = 5,\n                                   diff_to_time = TRUE,\n                                   time_unit = \"year\"){\n  df <- map2_dfr(coherence_list, names(coherence_list), \\(coherence, label) {\n    # if only one period is given -> select the closest period\n    # else select all period within the range\n    row_period <- if (length(period) == 1)\n      which.min(abs(coherence$Period - period)) else\n      which((coherence$Period >= min(period)) &\n              (coherence$Period <= max(period)))\n    \n    data.frame(\n      date = coherence$series$date,\n      phase_diff = if (length(row_period) > 1)\n        colMeans(coherence$Angle[row_period, ]) else\n        coherence$Angle[row_period, ]\n    ) %>% \n      mutate(\n        phase_diff = if(diff_to_time) phase_diff*mean(period)/(2*pi) else phase_diff,\n        label = label\n      )\n  })\n  \n  plot <- df %>% \n    ggplot() +\n    geom_line(\n      aes(x = date, y = phase_diff, color = label)\n    ) +\n    labs(\n      x = \"Date\",\n      y = paste0(\"Phase difference (\", if(diff_to_time) time_unit else \"radian\",\")\" )\n    ) +\n    geom_hline(\n      aes(yintercept = 0), linetype = \"dashed\", color = \"black\"\n    )\n  \n  list(\n    df = df, \n    plot = plot\n  )\n}\n\n\n\n5-year2-year\n\n\n\ncompute_phase_diff(countries_coherence, period = c(4.5,5))$plot\n\n\n\n\n\n\n\ncompute_phase_diff(countries_coherence, period = 2.5, diff_to_time = TRUE)$plot\n\n\n\n\n\n\n\n\n\nSynchrony\nSynchrony is computed using the following formula\n\\[\n\\text{coherence} \\cdot |1 - \\frac{ \\theta_{diff}}{\\pi}|\n\\]\nWhere \\(\\theta_{diff}\\) is the phase difference (in radians)\nSuch that high coherence with small phase difference is closer to 1 (i.e. more closely aligned).\n\n\nFunction to compute synchrony\n# Methodology proposed in the paper 10.1126/scitranslmed.adq4326\n# Synchrony closer to 1 the better\ncompute_synchrony <- function(coherence_list, period = 5){\n  df <- map2_dfr(coherence_list, names(coherence_list), \\(coherence, label) {\n    # if only one period is given -> select the closest period\n    # else select all period within the range\n    row_period <- if (length(period) == 1)\n      which.min(abs(coherence$Period - period)) else\n      which((coherence$Period >= min(period)) &\n              (coherence$Period <= max(period)))\n    \n    data.frame(\n      date = coherence$series$date,\n      phase_diff = if (length(row_period) > 1)\n        colMeans(coherence$Angle[row_period, ]) else\n        coherence$Angle[row_period, ],\n      coherence = if (length(row_period) > 1)\n        colMeans(coherence$Coherence[row_period, ]) else\n        coherence$Coherence[row_period, ]\n    ) %>% \n      mutate(\n        synchrony = abs(1 - phase_diff/pi) * coherence,\n        label = label\n      )\n  })\n  \n  plot <- df %>% \n    ggplot() +\n    geom_line(\n      aes(x = date, y = synchrony, color = label)\n    ) +\n    labs(\n      x = \"Date\",\n      y = \"Synchrony\"\n    ) +\n    geom_hline(\n      aes(yintercept = 1), linetype = \"dashed\", color = \"black\"\n    )\n  \n  list(\n    df = df, \n    plot = plot\n  )\n}\n\n\n\n5-year2-year\n\n\n5-year period synchrony\n\nmultiannual_synch <- compute_synchrony(countries_coherence, period = 5)\nmultiannual_synch$plot\n\n\n\n\n\n\nbiennial synchrony\n\nbiennial_synch <- compute_synchrony(countries_coherence, period = 2.5)\nbiennial_synch$plot"
  },
  {
    "objectID": "wavelet.html#sea-map",
    "href": "wavelet.html#sea-map",
    "title": "Wavelet analysis",
    "section": "SEA map",
    "text": "SEA map\n\n\nGet map data of SEA countries\nlibrary(geodata)\nlibrary(countrycode)\nlibrary(sf)\nlibrary(CoordinateCleaner)\n\n# convert contry name as ISO vec\nsea_iso <- countrycode(filtered_countries, origin = \"country.name\", destination = \"iso3c\")\nanalyzed_iso <- countrycode(names(countries_wavelets), origin = \"country.name\", destination = \"iso3c\")\n\n# get gadm map \nmap_data <- map_dfr(sea_iso, \\(iso){\n  data <- gadm(iso, level = 0, path = \"data/gadm/\")\n  \n  data.frame(\n    iso = iso,\n    sf = st_as_sf(data),\n    status = ifelse(iso %in% analyzed_iso, \"analyzed\", \"excluded\")\n  )\n})\n\n\n\nGet SEA map\n\n\ngenerate SEA map\nsea_plot <- map_data %>% \n  mutate(\n    country = if_else(status == \"analyzed\", \n                      countrycode(iso, origin = \"iso3c\", destination = \"country.name\"), \n                      NA)\n  ) %>% \n  ggplot() +\n    geom_sf(aes(geometry = sf.geometry, fill = country)) +\n    scale_fill_discrete(\n      na.value = \"grey80\",\n      labels = \\(x) if_else(is.na(x), \"Excluded\", x)\n    )\n\n\nPrepare data for countries pairs\n\n\nGenerate data to plot arrow\n# expected input to be the output from function compute_synchrony\nprepare_plot_data <- function(synchrony_out, centroid_df = iso_centroid){\n  synchrony_out$df %>% \n    # ---- compute mean coherence-weighted phase difference\n    group_by(label) %>% \n    summarize(\n      avg_phase_diff = sum(coherence * phase_diff)/sum(coherence)\n    ) %>% \n    separate(label, into = c(\"from\", \"to\"), sep = \" - \") %>% \n    mutate(\n      from = countrycode(from, origin = \"country.name\", destination = \"iso3c\"),\n      to = countrycode(to, origin = \"country.name\", destination = \"iso3c\")\n    ) %>% \n    # ---- swap from and to countries if the avg_phase_diff is negative (i.e. the \"to\" is actually the leading time series)\n    mutate(\n      tmp = if_else(avg_phase_diff < 0, from, to),\n      from = if_else(avg_phase_diff < 0, to, from),\n      to = tmp,\n      # since we already use the sign for determine the direction, keep absolute value only\n      avg_phase_diff = abs(avg_phase_diff)\n    ) %>% select(-tmp) %>% \n    # ---- get the coordinate of the centroid of each country\n    left_join(\n      # get coordinate of centroid of origin country \n      centroid_df %>% rename(from_x = x, from_y = y),\n      by = join_by(from == iso)\n    ) %>% \n    left_join(\n      # get coordinate of centroid of destination country\n      centroid_df %>% rename(to_x = x, to_y = y),\n      by = join_by(to == iso)\n    )\n}\n\n# get data.frame of iso and coordinate of centroid of that country\n# iso_centroid <- map_data %>% \n#   as_tibble() %>% \n#   mutate(\n#     centroid = st_coordinates(st_point_on_surface(sf.geometry)),\n#     x = centroid[,\"X\"],\n#     y = centroid[,\"Y\"]\n#   ) %>% \n#   select(iso, x, y)\n\n# try centroid from CoordinateCleaner package\niso_centroid <- countryref %>% \n  filter(\n    iso3 %in% sea_iso,\n    type == \"country\"\n  ) %>% \n  # for each country, only keep the first record\n  group_by(iso3) %>% \n  slice(1) %>% \n  ungroup() %>% \n  rename(\n    iso = iso3,\n    x = centroid.lon,\n    y = centroid.lat\n  ) %>% \n  select(iso, x, y)\n\n\n\n\nVietnam measles wave\nVisualize the direction of measles wave relative to Vietnam.\nGeneral interpretation of the plot:\n\nArrow indicates which time series leads (to) the other (i.e., pointing from the leading one to the lagging one).\nArrow boldness is determined by the absolute coherence-weighted average weight difference. Bolder arrow indicates that the lagging time series is more closely aligned with the leading time series.\n\n\n5-year2.5-year\n\n\nThe plot suggests that major measles cycle in Vietnam (roughly every 5-year) usually happen after Thailand and/or Philippines.\n\n\nCode\nmultiannual_direction <- prepare_plot_data(multiannual_synch)\nsea_plot +\n  geom_segment(\n    aes(x = from_x, y = from_y, xend = to_x, yend = to_y, alpha = avg_phase_diff),\n    color = \"black\",\n    arrow = grid::arrow(length = unit(0.2,\"cm\")),\n    data = multiannual_direction\n  ) + \n  scale_alpha(range = c(1, 0.3)) +\n  labs(\n    x = \"\", y = \"\",\n    fill = \"country\",\n    alpha = \"|avg. phase diff|\"\n  )\n\n\n\n\n\n\n\nThe plot suggests that the (roughly) biennial measles cycle in Thailand and/or Philippines usually happen shortly after Vietnam.\n\n\nCode\nbiennual_direction <- prepare_plot_data(biennial_synch)\nsea_plot +\n  geom_segment(\n    aes(x = from_x, y = from_y, xend = to_x, yend = to_y, alpha = avg_phase_diff),\n    color = \"black\",\n    arrow = grid::arrow(length = unit(0.2,\"cm\")),\n    data = biennual_direction\n  ) +\n  scale_alpha(range = c(1, 0.3)) +\n  labs(\n    x = \"\", y = \"\",\n    fill = \"country\",\n    alpha = \"|avg. phase diff|\"\n  )\n\n\n\n\n\n\n\n\n\n\nSEA countries\nVisualize the flow of measles between SEA countries, following these steps:\n\nPerform bi-wavelet analysis on all pairs of countries\nCompute coherence-weighted average phase difference (CAPD), the result is in radian.\nGenerate the arrows:\n\nFor each origin country, create an arrow to the destination country with lowest absolute CAPD value.\nAlpha value for the arrow is also determined by absolute CAPD value, where bolder color indicates lower absolute CAPD.\n\n\n\n\nCompute coherence of all country pairs\nall_countries_coherence <- log_transformed %>% \n    filter(country %in% analyze_countries) %>% \n    generate_biwavelet_analysis(ref_country = NA)\n\n\n\n\nCompute synchrony\nall_countries_synch <- compute_synchrony(all_countries_coherence, period = 5)\n\n\n\n\nCompute measles direction between SEA countries\nall_countries_direction <- prepare_plot_data(all_countries_synch)\n\n\n\n\nGet the data for plotting direction of measles\nnearest_flow <- all_countries_direction %>% \n      mutate(\n        # update code for origin country \n        from = countrycode(from, origin = \"iso3c\", destination = \"country.name\")\n      ) %>% \n      # for each origin country, keep the lowest absolute average phase difference\n      group_by(from) %>% \n      filter(abs(avg_phase_diff) == min(abs(avg_phase_diff))) %>% \n      ungroup()\n\nsea_plot +\n  geom_segment(\n    aes(\n      x = from_x, y = from_y, xend = to_x, yend = to_y, \n      alpha = avg_phase_diff),\n    color = \"black\",\n    arrow = grid::arrow(length = unit(0.2,\"cm\"), angle = 20),\n    data = nearest_flow\n  ) +\n  scale_alpha(range = c(1, 0.3)) +\n  labs(\n    x = \"\", y = \"\",\n    fill = \"country\",\n    alpha = \"Absolute avg. phase diff\"\n  )"
  },
  {
    "objectID": "wavelet.html#correlation-to-distance",
    "href": "wavelet.html#correlation-to-distance",
    "title": "Wavelet analysis",
    "section": "Correlation to distance",
    "text": "Correlation to distance\nDistance between 2 countries are defined as the distance between centroids.\nOnly 5-year period is visualized here\n\n\nPrepare data for plotting\ncountries_avg <- all_countries_synch$df %>% \n  group_by(label) %>% \n  summarize(\n    avg_synchrony = mean(synchrony),\n    avg_coherence = mean(coherence),\n    # convert phase diff from radians to years\n    avg_abs_phasediff = mean(abs(phase_diff))*5/(2*pi)\n  ) %>% \n  ungroup() %>% \n  # get centroid of each country pairs\n  separate(label, into = c(\"from\", \"to\"), sep = \" - \") %>% \n  mutate(\n    from = countrycode(from, origin = \"country.name\", destination = \"iso3c\"),\n    to = countrycode(to, origin = \"country.name\", destination = \"iso3c\")\n  ) %>% \n  left_join(\n    # get coordinate of centroid of origin country \n    iso_centroid %>% rename(from_x = x, from_y = y),\n      by = join_by(from == iso)\n  ) %>% \n  left_join(\n    # get coordinate of centroid of destination country\n    iso_centroid %>% rename(to_x = x, to_y = y),\n    by = join_by(to == iso)\n  )\n\n\n# compute distance\nfrom_pts <- st_as_sf(countries_avg, coords = c(\"from_x\", \"from_y\"), crs = 4326)\nto_pts   <- st_as_sf(countries_avg, coords = c(\"to_x\", \"to_y\"), crs = 4326)\ndistances <- st_distance(from_pts, to_pts, by_element = TRUE)\n\ncountries_avg <- countries_avg %>% \n  mutate(\n    # convert to km\n    distances = as.numeric(distances)/1000\n  )\n\n\n\nSynchrony\n\n\nCode\ncountries_avg %>% \n  ggplot(aes(x = distances, y = avg_synchrony)) +\n    geom_point() +\n    geom_smooth(\n      color = \"cornflowerblue\",\n      fill = \"cornflowerblue\",\n      method = \"loess\"\n    ) + \n    labs(\n      x = \"Distance (km)\",\n      y = \"Average Synchrony\"\n    )\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nCoherence\n\n\nCode\ncountries_avg %>% \n  ggplot(aes(x = distances, y = avg_coherence)) +\n    geom_point() +\n    geom_smooth(\n      method = \"loess\",\n      color = \"cornflowerblue\",\n      fill = \"cornflowerblue\",\n    ) + \n    labs(\n      x = \"Distance (km)\",\n      y = \"Average Coherence\"\n    )\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nPhase difference\nVisualize the average lag between 2 time series as distance grow\n\n\nCode\ncountries_avg %>% \n  ggplot(aes(x = distances, y = avg_abs_phasediff)) +\n    geom_point() +\n    geom_smooth(\n      method = \"loess\",\n      color = \"cornflowerblue\",\n      fill = \"cornflowerblue\",\n    ) + \n    labs(\n      x = \"Distance (km)\",\n      y = \"Average absolute phase difference (year)\"\n    )\n\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "modelling.html",
    "href": "modelling.html",
    "title": "Modeling",
    "section": "",
    "text": "Goal:\n\nbuild a model to explain the synchrony/coherence observed from the wavelet analysis"
  },
  {
    "objectID": "wavelet.html#biwavelet-analysis",
    "href": "wavelet.html#biwavelet-analysis",
    "title": "Wavelet analysis",
    "section": "Biwavelet analysis",
    "text": "Biwavelet analysis\nFollow these steps of cross-wavelet analysis:\n\nInspect the cross-wavelet power spectrum: identify the period that consistently recurring for both pair of time series.\nInspect the coherence spectrum: identify the period where the pair of time series consistently correlates.\nInspect the period-specific phase difference: check the relative timing of the 2 time series (which series lead the other).\nCompute and inspect the period-specific synchrony: check how closely the 2 time series align.\n\n\n\nFunction to generate biwavelet analyses for multiple pairs\nlibrary(janitor)\n\n# Function that takes data instead of wavelets\n# wavelets, period = 5, ref_country = \"Viet Nam\", constraint = TRUE, diff_to_time = TRUE\n# when ref_country is not found, generate all unique pairs \ngenerate_biwavelet_analysis <- function(data, \n                                        ref_country = \"Viet Nam\",\n                                        verbose = FALSE){\n  countries <- unique(data$country)\n  \n  # generate all unique pairs\n  pairs <- combn(countries, 2, simplify = FALSE)\n  \n  # if ref country is provided, keep pairs with the ref_country\n  # also make sure ref country is the first time series\n  if (!is.na(ref_country)){\n    pairs <- keep(pairs, \\(p) ref_country %in% p)\n    pairs <- map(pairs, \\(p) {\n      if (p[1] == ref_country) p else rev(p)\n    })\n  }\n  \n  coherence <- map(pairs, \\(curr_pair){\n    capture.output(\n      out <- data %>% \n      filter(\n        country %in% curr_pair\n      ) %>% \n      select(country, date, incidence) %>% \n      pivot_wider(\n        names_from = country,\n        values_from = incidence\n      ) %>%\n      as.data.frame() %>% \n      analyze.coherency(\n        my.pair = curr_pair,\n        dt = 1/12,\n        lowerPeriod = 1/6,\n        upperPeriod = 8,\n        verbose = verbose\n      )\n    ) %>% invisible()\n    \n    out\n  })\n  \n  names(coherence) <- map_chr(pairs, \\(pair) paste(pair, collapse = \" - \"))\n\n  coherence\n}\n\n\n\n\nFunction to generate cross-wavelet power spectrum plot\nplot_cwavelet_power <- function(coherence_list){\n  # return heatmap of power and also global power\n  imap(coherence_list, \\(coherence, label){\n    wc.image(\n        coherence,\n        # set significance level for drawing contour (white line around an area)\n        siglvl.contour = 0.1, \n        # set significance level for drawing arrows\n        siglvl.arrow = 0.05, which.arrow.sig = \"wt\",\n        main = paste0(label, \" power spectrum\"),\n        legend.params = list(lab = \"cross-wavelet power\"),\n        periodlab = \"Period(Year)\",\n        show.date = TRUE\n      )\n    \n    wc.avg(\n        coherence,\n        main = paste0(label, \" global power\")\n      )\n  })\n}\n\n\n\ncapture.output(\n  countries_coherence <- log_transformed %>% \n    filter(country %in% analyze_countries) %>% \n    generate_biwavelet_analysis()\n) %>% invisible()\n\n\nCross-wavelet power spectrum\nInterpretation of the arrows:\n\nhorizontal arrows pointing to the right indicate in-phase\nhorizontal arrows pointing to the left indicate anti-phase\n\nSome notable observations at the 4-5 period (major epidemics cycle):\n\nthe measles cycle of Vietnam - Philippines started out in-phase but slowly turns out of phase at the end\nthe measles cycle of Vietnam - Thailand started out out of phase phase but slowly out turns in-phase (around the 2021 year mark)\n\n\nplot_cwavelet_power(countries_coherence)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n$`Viet Nam - Indonesia`\nNULL\n\n$`Viet Nam - Malaysia`\nNULL\n\n$`Viet Nam - Myanmar`\nNULL\n\n$`Viet Nam - Philippines`\nNULL\n\n$`Viet Nam - Thailand`\nNULL\n\n\n\n\nCoherence\nPlot coherence over time-period\n\n\nFunction to plot coherence\nplot_coherence <- function(coherence_list){\n  out <- map2(names(coherence_list), coherence_list, \\(label, analysis){\n      wc.image(\n        analysis,\n        which.image = \"wc\",\n        # set significance level for drawing contour (white line around an area)\n        siglvl.contour = 0.1, \n        # set significance level for drawing arrows\n        siglvl.arrow = 0.05, which.arrow.sig = \"wt\",\n        main = paste0(label, \" coherence plot\"),\n        legend.params = list(lab = \"wavelet coherence level\"),\n        periodlab = \"Period(Year)\",\n        show.date = TRUE\n      )\n  })\n  \n  names(out) <- names(coherence_list)\n  out\n}\n\n\n\nwc_plots <- plot_coherence(countries_coherence)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot average coherence at each period across time\n\n\nFunction to plot average coherence\nplot_avg_coherence <- function(coherence_list){\n  map2(names(coherence_list), coherence_list, \\(label, analysis){\n    # compute data for plotting\n    df <- data.frame(\n      period = analysis$Period,\n      avg_coherence = analysis$Coherence.avg,\n      p_val = analysis$Coherence.avg.pval\n    ) %>% \n      mutate(\n        p_val_label = case_when(\n          p_val <= 0.05 ~ \"<= 0.05\",\n            p_val <= 0.1 ~ \"<= 0.1\",\n            .default = \">0.1\"\n        )\n      )\n    \n    ggplot() +\n      geom_line(\n        aes(\n          x = period, y = avg_coherence\n        ),\n        data = df\n      ) +\n      geom_point(\n        aes(\n          x = period, y = avg_coherence, color = p_val_label\n        ), \n        data = df %>% filter(p_val_label != \">0.1\")\n      ) + \n      labs(\n        title = paste0(\"Average coherence of \", label),\n        x = \"Period\",\n        y = \"Coherence\",\n        color = \"p-value\"\n      )\n  })\n}\n\n\n\nplot_avg_coherence(countries_coherence)\n\n[[1]]\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n[[3]]\n\n\n\n\n\n\n[[4]]\n\n\n\n\n\n\n[[5]]\n\n\n\n\n\n\n\nPhase difference\n\n\nFunction to compute phase difference\n# alternative way to get phase difference\ncompute_phase_diff <- function(coherence_list, period = 5,\n                                   diff_to_time = TRUE,\n                                   time_unit = \"year\"){\n  df <- map2_dfr(coherence_list, names(coherence_list), \\(coherence, label) {\n    # if only one period is given -> select the closest period\n    # else select all period within the range\n    row_period <- if (length(period) == 1)\n      which.min(abs(coherence$Period - period)) else\n      which((coherence$Period >= min(period)) &\n              (coherence$Period <= max(period)))\n    \n    data.frame(\n      date = coherence$series$date,\n      phase_diff = if (length(row_period) > 1)\n        colMeans(coherence$Angle[row_period, ]) else\n        coherence$Angle[row_period, ]\n    ) %>% \n      mutate(\n        phase_diff = if(diff_to_time) phase_diff*mean(period)/(2*pi) else phase_diff,\n        label = label\n      )\n  })\n  \n  plot <- df %>% \n    ggplot() +\n    geom_line(\n      aes(x = date, y = phase_diff, color = label)\n    ) +\n    labs(\n      x = \"Date\",\n      y = paste0(\"Phase difference (\", if(diff_to_time) time_unit else \"radian\",\")\" )\n    ) +\n    geom_hline(\n      aes(yintercept = 0), linetype = \"dashed\", color = \"black\"\n    )\n  \n  list(\n    df = df, \n    plot = plot\n  )\n}\n\n\n\n5-year2.5-year\n\n\n\ncompute_phase_diff(countries_coherence, period = 5)$plot\n\n\n\n\n\n\n\ncompute_phase_diff(countries_coherence, period = 2.5, diff_to_time = TRUE)$plot\n\n\n\n\n\n\n\n\n\nSynchrony\nSynchrony is computed using the following formula\n\\[\n\\text{coherence} \\cdot |1 - \\frac{ \\theta_{diff}}{\\pi}|\n\\]\nWhere \\(\\theta_{diff}\\) is the phase difference (in radians)\nSuch that high coherence with small phase difference is closer to 1 (i.e. more closely aligned).\n\n\nFunction to compute synchrony\n# Methodology proposed in the paper 10.1126/scitranslmed.adq4326\n# Synchrony closer to 1 the better\ncompute_synchrony <- function(coherence_list, period = 5){\n  df <- map2_dfr(coherence_list, names(coherence_list), \\(coherence, label) {\n    # if only one period is given -> select the closest period\n    # else select all period within the range\n    row_period <- if (length(period) == 1)\n      which.min(abs(coherence$Period - period)) else\n      which((coherence$Period >= min(period)) &\n              (coherence$Period <= max(period)))\n    \n    data.frame(\n      date = coherence$series$date,\n      phase_diff = if (length(row_period) > 1)\n        colMeans(coherence$Angle[row_period, ]) else\n        coherence$Angle[row_period, ],\n      coherence = if (length(row_period) > 1)\n        colMeans(coherence$Coherence[row_period, ]) else\n        coherence$Coherence[row_period, ]\n    ) %>% \n      mutate(\n        synchrony = abs(1 - phase_diff/pi) * coherence,\n        label = label\n      )\n  })\n  \n  plot <- df %>% \n    ggplot() +\n    geom_line(\n      aes(x = date, y = synchrony, color = label)\n    ) +\n    labs(\n      x = \"Date\",\n      y = \"Synchrony\"\n    ) +\n    geom_hline(\n      aes(yintercept = 1), linetype = \"dashed\", color = \"black\"\n    )\n  \n  list(\n    df = df, \n    plot = plot\n  )\n}\n\n\n\n5-year2.5-year\n\n\n5-year period synchrony\n\nmultiannual_synch <- compute_synchrony(countries_coherence, period = 5)\nmultiannual_synch$plot\n\n\n\n\n\n\nRoughly biennial synchrony\n\nbiennial_synch <- compute_synchrony(countries_coherence, period = 2.5)\nbiennial_synch$plot"
  }
]