---
title: "Wavelet analysis"
---

Goal:

-   Check synchrony in the number of measles cases between SEA countries

-   Method: wavelet analysis to assess:

    -   Seasonal pattern (1 year cycle, depends on school year, etc.)

    -   Multiannual patterns (multiple years, typically years between major epidemics)

## Data processing

### Load data

```{r}
#| code-fold: true
#| code-summary: "Load measles epicurve data for SEA countries"
suppressMessages(library(tidyverse))
library(janitor)
library(plotly)
library(patchwork)

world_epi_curve <- readxl::read_excel(
  "data/404-table-web-epi-curve-data.xlsx",
  sheet = "WEB")

# --- preprocess ----- 
world_epi_curve <- world_epi_curve %>% 
  clean_names() %>% 
  mutate(
    date = ym(str_c(year, month)),
    measles_clinical = as.integer(measles_clinical)
  ) 

filtered_countries <- c(
  "Viet Nam", "Thailand", "Cambodia", "Malaysia", "Singapore", "Myanmar", "Philippines","Brunei Darussalam", "Timor-Leste", "Indonesia",
  "Lao People's Democratic Republic")

# get epi curve of South East Asia countries
sea_epi_curve <- world_epi_curve %>% 
  clean_names() %>% 
  mutate(
    date = ym(str_c(year, month)),
    measles_suspect = as.integer(measles_suspect),
    measles_clinical = as.integer(measles_clinical),
    measles_epi_linked = as.integer(measles_epi_linked),
    measles_lab_confirmed = as.integer(measles_lab_confirmed),
    # NOTE: recompute measles total since some epi-linked cases are negative (e.g. record for Indonesia on 2016-10-01)
    # definition: t sum of clinically-compatible, epidemiologically linked and laboratory-confirmed cases
    measles_total = abs(measles_clinical) + abs(measles_epi_linked) + abs(measles_lab_confirmed)
  ) %>% 
  filter(
    country %in% filtered_countries
  ) 
```

### Clean data

-   The column used for incidence data is measles total (sum of clinical compatible cases, epi-linked cases, laboratory confirmed cases)

-   Make sure the the time series is even-spaced

-   Check % of missing data from each of the 11 SEA countries

```{r}
#| code-fold: true
#| code-summary: "Generate evenly spaced time series for all countries"
date_range <- range(sea_epi_curve$date)
sea_epi_curve <- sea_epi_curve %>% 
  group_by(country) %>%
  rename(
    incidence = measles_total
  ) %>% 
  complete(
    date = seq(date_range[1], date_range[2], by = "month"),
    fill = list(
      incidence = 0
    )
  ) %>% 
  ungroup()
```

View the percentage of data points where `incidence==0`

```{r}
#| code-fold: true
#| code-summary: "Get country with most incidence report being 0"

percent_zero <- sea_epi_curve %>% 
  group_by(country) %>% 
  summarize(
    percent_zero = sum(incidence == 0)/n()
  ) %>% 
  arrange(
    desc(percent_zero)
  ) 

# filtered out countries where percent of data points where incidence = 0 > 50%
high_pct_zero <- percent_zero %>% filter(percent_zero > 0.5) %>% pull(country)
```

### Plot incidence

```{r}
#| code-fold: true
#| code-summary: "Plor raw incidence"
sea_epicurve_plot <- sea_epi_curve %>% 
  filter(!(country %in% high_pct_zero)) %>% 
  ggplot() +
  geom_line(
    aes(
      x = date,
      y = incidence,
      color = country
    )
  ) 

ggplotly(sea_epicurve_plot)
```

### Preprocess data

Follow these steps

-   Log transform

-   Normalized

-   Remove latest observation of each country (most likely under-reported)

```{r}
#| code-fold: true
#| code-summary: "Preprocess data"
filtered_sea_epicurve <- sea_epi_curve %>% 
  filter(!(country %in% high_pct_zero)) 

log_transformed <- filtered_sea_epicurve %>% 
  group_by(country) %>% 
  mutate(
    # log transform
    incidence = log10(incidence + 1),
    # normalized
    incidence = (incidence - mean(incidence))/sd(incidence)
  ) %>% 
  filter(
    date != max(date)
  ) %>% 
  ungroup()
```

```{r}
#| code-fold: true
#| code-summary: "Plot preprocessed data"
log_epicurve_plot <- log_transformed %>% 
  ggplot() +
  geom_line(
    aes(
      x = date,
      y = incidence,
      color = country
    )
  ) 

ggplotly(log_epicurve_plot)
```

## Wavelet analysis

```{r}
library(WaveletComp)
```

Follow these steps of wavelet analysis

-   Inspect the **power spectrum across time-period domain**: identify the period that is consistently high over time, which indicates recurring cycles in the time series.

-   Inspect the **global power** (time-averaged power, analogue of the Fourier transform): identify the overall dominant periodicities.

-   Inspect the **period-specific reconstructed component**: extract period-specific oscillations to assess their contributions to the time series.

-   Inspect the **period-specific phase**: visualize the timing of cycles of different time series.

***General setup***

-   1 time unit is 1 year. Since the data is collected every month, `dt = 1/12`

-   The analyzed range of period is `[1/6, 8]` (i.e., 2 months to 8 years)

### Analyze on Vietnam data only

***1. Check power spectrum across time-period***

-   Consistently high power at `period=5` suggests a cycle of major epidemic every 5-years, which can be observed from indicence data.

-   The plot also suggests (roughly) biennial cycle.

-   Annual cycle (seasonality) is only weakly detected before 2017 (maybe due to under-reporting).

```{r}
#| code-fold: true
#| code-summary: "Code"
wavelet <- log_transformed %>% 
  filter(
    country == "Viet Nam"
  ) %>% 
  analyze.wavelet(
    my.series = "incidence",
    dt = 1/12,
    lowerPeriod = 1/6,
    upperPeriod = 8
  )

wt.image(wavelet, 
         # n.levels = 250, 
         legend.params = list(lab = "Power"),
         periodlab = "Period(Year)",
         show.date=TRUE)
```

***2. View global power (i.e., mean power across time)***

```{r}
wt.avg(wavelet)
```

```{r, include=FALSE}
#| code-fold: true
#| code-summary: "Code"
data.frame(
  period = wavelet$Period,
  power = wavelet$Power.avg,
  p_val = wavelet$Power.avg.pval
) %>% 
  ggplot() +
    geom_line(
        aes(
          x = period, 
          y = power        
        )
      ) +
    geom_point(
      aes(
        x = period, 
        y = power,
        alpha = p_val
      ),
      color = "red"
    )
```

***3. Check the period specific reconstructed component***

::: panel-tabset
## 5-year

reconstructed component for 5-year period

```{r}
#| code-fold: true
#| code-summary: "Code"
reconstruct(
  wavelet,
  sel.period = 5,
  plot.rec = TRUE,
  show.date = TRUE
)
```

## 2-year

Reconstructed component for 2-year period (biennial)

```{r}
#| code-fold: true
#| code-summary: "Code"
reconstruct(
  wavelet,
  sel.period = 2,
  plot.rec = TRUE,
  show.date = TRUE
)
```

## 1-year

Reconstructed component for 1-year period (seasonal)

```{r}
#| code-fold: true
#| code-summary: "Code"
reconstruct(
  wavelet,
  sel.period = 1,
  plot.rec = TRUE,
  show.date = TRUE
)
```
:::

***4. Visualize phase angle (in radians)***

::: panel-tabset
## 5-year

```{r}
#| code-fold: true
#| code-summary: "Plot phase"

# get the column for the 5-year period
row_5year <- which.min(abs(wavelet$Period - 5))

data.frame(
  date = wavelet$series$date,
  phase = wavelet$Phase[row_5year,]
) %>% 
  ggplot() +
  geom_line(
    aes(
      x = date,
      y = phase
    ), color = "cornflowerblue"
  )
```

## 2-year

```{r}
#| code-fold: true
#| code-summary: "Plot phase"

# get the column for the 2-year period
row_2year <- which.min(abs(wavelet$Period - 2))

data.frame(
  date = wavelet$series$date,
  phase = wavelet$Phase[row_2year,]
) %>% 
  ggplot() +
  geom_line(
    aes(
      x = date,
      y = phase
    ), color = "cornflowerblue"
  )
```
:::

### Perform analysis on all data

Exclusion criteria:

-   Percentage of records where `incidence = 0` greater than 50% (*Brunei*, *Timer-Leste*, *Laos*, *Cambodia*)

-   Low case count across time series (*Singapore*)

```{r}
#| code-fold: true
#| code-summary: "Perform wavelet data analysis on SEA countries"
analyze_countries <- c("Thailand", "Myanmar", "Philippines", "Viet Nam", 
                       "Malaysia", "Indonesia")

countries_wavelets <- log_transformed %>% 
  filter(country %in% analyze_countries) %>%
  group_by(country) %>% 
  nest() %>% 
  mutate(
    wavelet = map(data, \(dat){
      dat %>% 
      analyze.wavelet(
        my.series = "incidence",
        dt = 1/12, # 1 time unit = 1 year 
        lowerPeriod = 1/6, # 2 months
        upperPeriod = 8, #  years
        verbose = FALSE
      )
    })
  ) %>% 
  select(country, wavelet) %>%
  deframe()
```

### Power spectrum

These plots suggest that most analyzed SEA countries experience measles epidemic every 4-5 years

```{r}
#| code-fold: true
#| code-summary: "Function to plot power spectrum of all countries"

plot_power <- function(wavelets){
  # return heatmap of power and also global power
  imap(wavelets, \(wavelet, country){
    wt.image(
        wavelet,
        main = paste0(country, " power spectrum"),
        legend.params = list(lab = "Power"),
        periodlab = "Period(Year)",
        show.date = TRUE
      )
    
    wt.avg(
        wavelet,
        main = paste0(country, " global power")
      )
  })
}
```

```{r}
plot_power(countries_wavelets)
```

### Reconstructed component

```{r}
#| code-fold: true
#| code-summary: "Function to plot period specific component"
reconstruct_ts <- function(wavelets, period = 5){
  df <- map2_dfr(wavelets, names(wavelets), \(wavelet, country){
    rec_period <- reconstruct(
      wavelet,
      sel.period = period,
      plot.rec = FALSE,
      verbose = FALSE
    )
    
    rec_period$series %>%
      mutate(country = country, .before = 1)
  })
  
  plot <- df %>% 
    ggplot() +
      geom_line(
        aes(x = date, y = incidence.r, color = country)
      ) +
      labs(
        y = paste0(round(mean(period), digits = 2), "-year period component"),
        x = "Date"
      )
  
  # return data.frame and plot
  list(
    df = df,
    plot = plot
  )
}
```

::: panel-tabset
## 5-year

Take the average of the components of period ranging from 4-5.

Clear oscillations can be observed across all the countries, which further confirm the observations from previous section.

```{r}
ggplotly(
  reconstruct_ts(countries_wavelets, period = c(4,5))$plot
)
```

## 2-year

Roughly biennial component. Take the average of the components of period ranging from 1.9-2.5.

Relatively consistent oscillation can be observed for **Vietnam** and **Thailand** which suggests biennial cycle exists for these 2 countries.

```{r}
ggplotly(
  reconstruct_ts(countries_wavelets, period = c(1.9, 2.5))$plot
)
```

## 1-year

The plot suggests no SEA country exhibits an annual measles cycle

```{r}
ggplotly(
  reconstruct_ts(countries_wavelets, period = 1)$plot
)
```
:::

### Phase

```{r}
#| code-fold: true
#| code-summary: "Function to plot period-specific phase"
compute_phase <- function(wavelets, period = 5){
  df <- map2_dfr(wavelets, names(wavelets), \(wavelet, country){
    
    # if only one period is given -> select the closest period
    # else select all period within the range
    row_period <- if(length(period) == 1) which.min(abs(wavelet$Period - period)) else
      which( (wavelet$Period >= min(period)) & (wavelet$Period <= max(period)) )
    
    data.frame(
      date = wavelet$series$date,
      # compute mean phase across all selected periods
      phase = if(length(row_period) > 1) colMeans(wavelet$Phase[row_period,]) else wavelet$Phase[row_period,]
    ) %>% 
      mutate(
        country = country,
        .before = 1
      )
  })
  
  plot <- df %>% 
    ggplot() +
      geom_line(
        aes(x = date, y = phase, color = country)
      ) +
      labs(
        y = "Phase",
        x = "Date"
      )
  
  # return data.frame and plot
  list(
    df = df,
    plot = plot
  )
}
```

```{r include=FALSE}
#| code-fold: true
#| code-summary: "Function to plot period-specific phase difference"

# Manually compute phase difference
# There will be an alternative function to make use package (WaveletComp) functions later on
compute_phase_diff_alt <- function(wavelets, period = 5, ref_country = "Viet Nam", 
                               constraint = TRUE, diff_to_time = TRUE){
  # compute phase of each of these countries
  phases <- compute_phase(wavelets, period = period)$df
  
  ref_country_phase <- phases %>% 
    filter(
      country == ref_country
    ) %>% 
    select(-country)
  
  # get vector of remaining country
  remaining_countries <- phases %>% filter(country != ref_country) %>% pull(country) %>% unique()
  
  df <- map_dfr(remaining_countries, \(curr_country){
    
    data.frame(
      date = ref_country_phase$date,
      phase_diff = ref_country_phase$phase - phases %>% 
            filter(
              country == curr_country
            ) %>% pull(phase)
    ) %>% 
    mutate(
      # constraint the phase difference within +-pi
      phase_diff = if(constraint) ((phase_diff + 3*pi) %% (2*pi)) - pi else phase_diff,
      phase_diff = if(diff_to_time) phase_diff*mean(period)/(2*pi) else phase_diff,
      label = paste0(ref_country, "-", curr_country)
    )
  })
  
  plot <- df %>% 
    ggplot() +
      geom_line(
        aes(x = date, y = phase_diff, color = label)
      ) +
      geom_hline(
        aes(yintercept = 0),
        color = "black", linetype = "dashed"
      ) + 
    labs(
      title = paste0("Phase difference between ", ref_country, " and other countries"),
      xlab = "Date",
      y = paste0("Phase difference (in ", if(diff_to_time) "time unit" else "radians", ")")
    )
    
  list(
    df = df, plot = plot
  )
}
```

::: panel-tabset
## 5-year

Major epidemics cycle (roughly 5 years)

```{r}
countries_phase <- compute_phase(countries_wavelets, period = 5)

ggplotly(countries_phase$plot)
```

## 2-year

Roughly biennial epidemic

```{r}
countries_phase <- compute_phase(countries_wavelets, period = 2)

countries_phase$plot 
```
:::

## Cross-wavelet analysis

Follow these steps of cross-wavelet analysis:

-   Inspect the **cross-wavelet power spectrum**: identify the period that consistently recurring for both pair of time series.

-   Inspect the **coherence spectrum:** identify the period where the pair of time series consistently correlates.

-   Inspect the **period-specific phase difference:** check the relative timing of the 2 time series (which series lead the other).

-   Compute and inspect the **period-specific synchrony:** check how closely the 2 time series align.

```{r}
#| code-fold: true
#| code-summary: "Function to generate coherence analyses for multiple pairs"
library(janitor)

# Function that takes data instead of wavelets
# wavelets, period = 5, ref_country = "Viet Nam", constraint = TRUE, diff_to_time = TRUE
# when ref_country is not found, generate all unique pairs 
generate_coherence_analysis <- function(data, 
                                        ref_country = "Viet Nam",
                                        verbose = FALSE){
  countries <- unique(data$country)
  
  # generate all unique pairs
  pairs <- combn(countries, 2, simplify = FALSE)
  
  # if ref country is provided, keep pairs with the ref_country
  # also make sure ref country is the first time series
  if (!is.na(ref_country)){
    pairs <- keep(pairs, \(p) ref_country %in% p)
    pairs <- map(pairs, \(p) {
      if (p[1] == ref_country) p else rev(p)
    })
  }
  
  coherence <- map(pairs, \(curr_pair){
    data %>% 
      filter(
        country %in% curr_pair
      ) %>% 
      select(country, date, incidence) %>% 
      pivot_wider(
        names_from = country,
        values_from = incidence
      ) %>%
      as.data.frame() %>% 
      analyze.coherency(
        my.pair = curr_pair,
        dt = 1/12,
        lowerPeriod = 1/6,
        upperPeriod = 8,
        verbose = verbose
      )
  })
  
  names(coherence) <- map_chr(pairs, \(pair) paste(pair, collapse = " - "))

  coherence
}
```

```{r}
#| code-fold: true
#| code-summary: "Function to generate cross-wavelet power spectrum plot"

plot_cwavelet_power <- function(coherence_list){
  # return heatmap of power and also global power
  imap(coherence_list, \(coherence, label){
    wc.image(
        coherence,
        # set significance level for drawing contour (white line around an area)
        siglvl.contour = 0.1, 
        # set significance level for drawing arrows
        siglvl.arrow = 0.05, which.arrow.sig = "wt",
        main = paste0(label, " power spectrum"),
        legend.params = list(lab = "cross-wavelet power"),
        periodlab = "Period(Year)",
        show.date = TRUE
      )
    
    wc.avg(
        coherence,
        main = paste0(label, " global power")
      )
  })
}
```

```{r}
countries_coherence <- log_transformed %>% 
    filter(country %in% analyze_countries) %>% 
    generate_coherence_analysis()
```

### Cross-wavelet power spectrum

Interpretation of the arrows:

-   horizontal arrows pointing to the right indicate in-phase

-   horizontal arrows pointing to the left indicate anti-phase

Some notable observations at the 4-5 period (major epidemics cycle):

-   the measles cycle of Vietnam - Philippines started out in-phase but slowly turns out of phase at the end

-   the measles cycle of Vietnam - Thailand started out out of phase phase but slowly out turns in-phase (around the 2021 year mark)

```{r}
plot_cwavelet_power(countries_coherence)
```

### Coherence

Plot coherence over time-period

```{r}
#| code-fold: true
#| code-summary: "Function to plot coherence"
plot_coherence <- function(coherence_list){
  out <- map2(names(coherence_list), coherence_list, \(label, analysis){
      wc.image(
        analysis,
        which.image = "wc",
        # set significance level for drawing contour (white line around an area)
        siglvl.contour = 0.1, 
        # set significance level for drawing arrows
        siglvl.arrow = 0.05, which.arrow.sig = "wt",
        main = paste0(label, " coherence plot"),
        legend.params = list(lab = "wavelet coherence level"),
        periodlab = "Period(Year)",
        show.date = TRUE
      )
  })
  
  names(out) <- names(coherence_list)
  out
}
```

```{r}
wc_plots <- plot_coherence(countries_coherence)
```

Plot average coherence at each period across time

```{r}
#| code-fold: true
#| code-summary: "Function to plot average coherence"
plot_avg_coherence <- function(coherence_list){
  map2(names(coherence_list), coherence_list, \(label, analysis){
    # compute data for plotting
    df <- data.frame(
      period = analysis$Period,
      avg_coherence = analysis$Coherence.avg,
      p_val = analysis$Coherence.avg.pval
    ) %>% 
      mutate(
        p_val_label = case_when(
          p_val <= 0.05 ~ "<= 0.05",
            p_val <= 0.1 ~ "<= 0.1",
            .default = ">0.1"
        )
      )
    
    ggplot() +
      geom_line(
        aes(
          x = period, y = avg_coherence
        ),
        data = df
      ) +
      geom_point(
        aes(
          x = period, y = avg_coherence, color = p_val_label
        ), 
        data = df %>% filter(p_val_label != ">0.1")
      ) + 
      labs(
        title = paste0("Average coherence of ", label),
        x = "Period",
        y = "Coherence",
        color = "p-value"
      )
  })
}
```

```{r}
plot_avg_coherence(countries_coherence)
```

### Phase difference

```{r}
#| code-fold: true
#| code-summary: "Function to compute phase difference"

# alternative way to get phase difference
compute_phase_diff <- function(coherence_list, period = 5,
                                   diff_to_time = TRUE,
                                   time_unit = "year"){
  df <- map2_dfr(coherence_list, names(coherence_list), \(coherence, label) {
    # if only one period is given -> select the closest period
    # else select all period within the range
    row_period <- if (length(period) == 1)
      which.min(abs(coherence$Period - period)) else
      which((coherence$Period >= min(period)) &
              (coherence$Period <= max(period)))
    
    data.frame(
      date = coherence$series$date,
      phase_diff = if (length(row_period) > 1)
        colMeans(coherence$Angle[row_period, ]) else
        coherence$Angle[row_period, ]
    ) %>% 
      mutate(
        phase_diff = if(diff_to_time) phase_diff*mean(period)/(2*pi) else phase_diff,
        label = label
      )
  })
  
  plot <- df %>% 
    ggplot() +
    geom_line(
      aes(x = date, y = phase_diff, color = label)
    ) +
    labs(
      x = "Date",
      y = paste0("Phase difference (", if(diff_to_time) time_unit else "radian",")" )
    ) +
    geom_hline(
      aes(yintercept = 0), linetype = "dashed", color = "black"
    )
  
  list(
    df = df, 
    plot = plot
  )
}
```

::: panel-tabset
## 5-year

```{r}
compute_phase_diff(countries_coherence, period = c(4.5,5))$plot
```

## 2-year

```{r}
compute_phase_diff(countries_coherence, period = 2.5, diff_to_time = TRUE)$plot
```
:::

### Synchrony

Synchrony is computed using the following formula

$$
\text{coherence} \cdot |1 - \frac{ \theta_{diff}}{\pi}|
$$

Where $\theta_{diff}$ is the phase difference (in radians)

Such that high coherence with small phase difference *is closer to 1* (i.e. more closely aligned).

```{r}
#| code-fold: TRUE
#| code-summary: "Function to compute synchrony"

# Methodology proposed in the paper 10.1126/scitranslmed.adq4326
# Synchrony closer to 1 the better
compute_synchrony <- function(coherence_list, period = 5){
  df <- map2_dfr(coherence_list, names(coherence_list), \(coherence, label) {
    # if only one period is given -> select the closest period
    # else select all period within the range
    row_period <- if (length(period) == 1)
      which.min(abs(coherence$Period - period)) else
      which((coherence$Period >= min(period)) &
              (coherence$Period <= max(period)))
    
    data.frame(
      date = coherence$series$date,
      phase_diff = if (length(row_period) > 1)
        colMeans(coherence$Angle[row_period, ]) else
        coherence$Angle[row_period, ],
      coherence = if (length(row_period) > 1)
        colMeans(coherence$Coherence[row_period, ]) else
        coherence$Coherence[row_period, ]
    ) %>% 
      mutate(
        synchrony = abs(1 - phase_diff/pi) * coherence,
        label = label
      )
  })
  
  plot <- df %>% 
    ggplot() +
    geom_line(
      aes(x = date, y = synchrony, color = label)
    ) +
    labs(
      x = "Date",
      y = "Synchrony"
    ) +
    geom_hline(
      aes(yintercept = 1), linetype = "dashed", color = "black"
    )
  
  list(
    df = df, 
    plot = plot
  )
}
```

::: panel-tabset
## 5-year

5-year period synchrony

```{r}
multiannual_synch <- compute_synchrony(countries_coherence, period = 5)
multiannual_synch$plot
```

## 2-year

biennial synchrony

```{r}
biennial_synch <- compute_synchrony(countries_coherence, period = 2.5)
biennial_synch$plot
```
:::

## SEA map

```{r}
#| code-fold: true
#| code-summary: "Get map data of SEA countries"
library(geodata)
library(countrycode)
library(sf)

# convert contry name as ISO vec
sea_iso <- countrycode(filtered_countries, origin = "country.name", destination = "iso3c")
analyzed_iso <- countrycode(names(countries_wavelets), origin = "country.name", destination = "iso3c")

map_data <- map_dfr(sea_iso, \(iso){
  data <- gadm(iso, level = 0, path = "data/gadm/")
  
  data.frame(
    iso = iso,
    sf = st_as_sf(data),
    status = ifelse(iso %in% analyzed_iso, "analyzed", "excluded")
  )
})
```

### Get SEA map

```{r}
# try plotting 
sea_plot <- map_data %>% 
  mutate(
    country = if_else(status == "analyzed", 
                      countrycode(iso, origin = "iso3c", destination = "country.name"), 
                      NA)
  ) %>% 
  ggplot() +
    geom_sf(aes(geometry = sf.geometry, fill = country)) +
    scale_fill_discrete(
      na.value = "grey80",
      labels = \(x) if_else(is.na(x), "Excluded", x)
    )
```

Prepare data for countries pairs

```{r}
#| code-fold: true
#| code-summary: "Generate data to plot arrow"
# expected input to be the output from function compute_synchrony
prepare_plot_data <- function(synchrony_out, centroid_df = iso_centroid){
  synchrony_out$df %>% 
    # ---- compute mean coherence-weighted phase difference
    group_by(label) %>% 
    summarize(
      avg_phase_diff = sum(coherence * phase_diff)/sum(coherence)
    ) %>% 
    separate(label, into = c("from", "to"), sep = " - ") %>% 
    mutate(
      from = countrycode(from, origin = "country.name", destination = "iso3c"),
      to = countrycode(to, origin = "country.name", destination = "iso3c")
    ) %>% 
    # ---- swap from and to countries if the avg_phase_diff is negative (i.e. the "to" is actually the leading time series)
    mutate(
      tmp = if_else(avg_phase_diff < 0, from, to),
      from = if_else(avg_phase_diff < 0, to, from),
      to = tmp,
      # since we already use the sign for determine the direction, keep absolute value only
      avg_phase_diff = abs(avg_phase_diff)
    ) %>% select(-tmp) %>% 
    # ---- get the coordinate of the centroid of each country
    left_join(
      # get coordinate of centroid of origin country 
      iso_centroid %>% rename(from_x = x, from_y = y),
      by = join_by(from == iso)
    ) %>% 
    left_join(
      # get coordinate of centroid of destination country
      iso_centroid %>% rename(to_x = x, to_y = y),
      by = join_by(to == iso)
    )
}

# get data.frame of iso and coordinate of centroid of that country
iso_centroid <- map_data %>% 
  as_tibble() %>% 
  mutate(
    centroid = st_coordinates(st_point_on_surface(sf.geometry)),
    x = centroid[,"X"],
    y = centroid[,"Y"]
  ) %>% 
  select(iso, x, y)
```

### Vietnam measles wave

Visualize the direction of measles wave relative to Vietnam.

General interpretation of the plot:

-   Arrow indicates which time series leads (to) the other (i.e., pointing from the leading one to the lagging one).

-   Arrow boldness is determined by the absolute coherence-weighted average weight difference. Bolder arrow indicates that the lagging time series is more closely aligned with the leading time series.

::: panel-tabset
## 5-year

The plot suggests that major measles cycle in Vietnam (roughly every 5-year) usually happen after Thailand and/or Philippines.

```{r}
#| code-fold: true
#| code-summary: "Code"
multiannual_direction <- prepare_plot_data(multiannual_synch)
sea_plot +
  geom_segment(
    aes(x = from_x, y = from_y, xend = to_x, yend = to_y, alpha = avg_phase_diff),
    color = "black",
    arrow = grid::arrow(length = unit(0.2,"cm")),
    data = multiannual_direction
  ) + 
  scale_alpha(range = c(1, 0.3)) +
  labs(
    x = "", y = "",
    fill = "country",
    alpha = "|avg. phase diff|"
  )
```

## 2.5-year

The plot suggests that the (roughly) biennial measles cycle in Thailand and/or Philippines usually happen shortly after Vietnam.

```{r}
#| code-fold: true
#| code-summary: "Code"
biennual_direction <- prepare_plot_data(biennial_synch)
sea_plot +
  geom_segment(
    aes(x = from_x, y = from_y, xend = to_x, yend = to_y, alpha = avg_phase_diff),
    color = "black",
    arrow = grid::arrow(length = unit(0.2,"cm")),
    data = biennual_direction
  ) +
  scale_alpha(range = c(1, 0.3)) +
  labs(
    x = "", y = "",
    fill = "country",
    alpha = "Absolute avg. phase diff"
  )
```
:::

### SEA countries

Visualize the flow of measles between SEA countries

```{r}
#| code-fold: true
#| code-summary: "Compute coherence of all country pairs"
all_countries_coherence <- log_transformed %>% 
    filter(country %in% analyze_countries) %>% 
    generate_coherence_analysis(ref_country = NA)
```

```{r}
#| code-fold: true
#| code-summary: "Compute synchrony"
all_countries_synch <- compute_synchrony(all_countries_coherence, period = 5)
```

```{r}
#| code-fold: true
#| code-summary: "Compute measles direction between SEA countries"
all_countries_direction <- prepare_plot_data(all_countries_synch)
```

```{r}
#| code-fold: true
#| code-summary: "Get the data for plotting direction of measles"
nearest_flow <- all_countries_direction %>% 
      mutate(
        # update code for origin country 
        from = countrycode(from, origin = "iso3c", destination = "country.name")
      ) %>% 
      # for each origin country, keep the lowest absolute average phase difference
      group_by(from) %>% 
      filter(abs(avg_phase_diff) == min(abs(avg_phase_diff))) %>% 
      ungroup()

sea_plot +
  geom_segment(
    aes(
      x = from_x, y = from_y, xend = to_x, yend = to_y, 
      alpha = avg_phase_diff),
    color = "black",
    arrow = grid::arrow(length = unit(0.2,"cm"), angle = 20),
    data = nearest_flow
  ) +
  scale_alpha(range = c(1, 0.3)) +
  labs(
    x = "", y = "",
    fill = "country",
    alpha = "Absolute avg. phase diff"
  )
```

## Correlation to other factors

TODO: Check correlation of the synchrony to other factors, e.g.:

-   Distance

-   Change in synchrony to Thailand and Philippines over time (suggest the source of measles changes b4 and after covid?)
